<?php
/**
 * @file
 * Brightcove module is an integration layer between any modules using
 * Brightcove API. It makes all necessary checks for the API and makes
 * settings available to the user.
 *
 * @author
 * Jakub Suchy <jakub@dynamiteheads.com>
 * Parts of code taken from Media Brightcove module by Aaron Winborn - http://advomatic.com
 *
 * Module development sponsored by Brightcove, Inc.
 *
 * References:
 *   - http://docs.brightcove.com/en/media/
 *   - http://support.brightcove.com/en/docs/category/players
 *   - http://support.brightcove.com/en/docs/media-api-error-message-reference
 *   - http://support.brightcove.com/en/docs/media-api-objects-reference
 */

define('BRIGHTCOVE_STATUS_COMPLETE', 'COMPLETE');
define('BRIGHTCOVE_STATUS_ERROR', 'ERROR');

define('BRIGHTCOVE_CLIENT_ID_NONE', '_none');

// Logo overlay alignment constants
define('BRIGHTCOVE_LOGO_TOP_LEFT', 'TOP_LEFT');
define('BRIGHTCOVE_LOGO_BOTTOM_LEFT', 'BOTTOM_LEFT');
define('BRIGHTCOVE_LOGO_BOTTOM_RIGHT', 'BOTTOM_RIGHT');
define('BRIGHTCOVE_LOGO_TOP_RIGHT', 'TOP_RIGHT');
define('BRIGHTCOVE_LOGO_IMAGE_TYPE', 'LOGO_OVERLAY');


define('BRIGHTCOVE_PLAYLIST_TYPE_MANUAL', 'PLAYLIST_MANUAL');
define('BRIGHTCOVE_PLAYLIST_TYPE_SMART', 'PLAYLIST_SMART');

// Default values
define('BRIGHTCOVE_CACHE_LIFETIME', 600);
define('BRIGHTCOVE_CACHE_FILE_PATH', 'sites/default/files/cache/');
define('BRIGHTCOVE_CACHE_FILE_EXT', 'cache');
define('BRIGHTCOVE_CACHE_MEMCACHE_PATH', 'localhost');
define('BRIGHTCOVE_CACHE_MEMCACHE_PORT', 11211);

// Without this brightcove_playlist_access() is not always found.
require_once 'brightcove.playlist.inc';

/**
 * Implements hook_menu().
 */
function brightcove_menu() {
  $items = [];

  $items['brightcove/callback/%'] = [
    'title' => 'Brightcove Ingestion callback',
    'type' => MENU_CALLBACK,
    'page callback' => 'brightcove_handle_ingest_callback',
    'page arguments' => [2],
    'access arguments' => ['access content'],
  ];

  $base = 'admin/config/media/brightcove';

  $items['brightcove/autocomplete/videos/%brightcove_client'] = [
    'title' => 'Video autocomplete',
    'description' => 'Callback function for listing videos in autocomplete fields',
    'type' => MENU_CALLBACK,
    'page callback' => 'brightcove_autocomplete_videos',
    'page arguments' => [3],
    'access arguments' => ['browse videos'],
  ];

  $items[$base] = [
    'title' => 'Brightcove settings',
    'description' => 'Configure Brigthcove integration, api keys, player settings, upload settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => ['brightcove_admin_settings'],
    'type' => MENU_NORMAL_ITEM,
    'access arguments' => ['administer brightcove settings'],
    'file' => 'brightcove.admin.inc',
  ];

  $items["{$base}/general"] = [
    'title' => 'General',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'access arguments' => ['administer brightcove settings'],
    'weight' => -1,
  ];

  return $items;
}

/**
 * Implements hook_entity_info().
 */
function brightcove_entity_info() {
  $entity_info = [];

  $entity_info['brightcove_client'] = [
    'label' => t('Brightcove client'),
    'base table' => 'brightcove_client',
    'revision table' => 'brightcove_client_revision',
    'uri callback' => 'brightcove_client_uri',
    'controller class' => 'BrightcoveClientEntityController',
    'entity class' => 'Entity',
    'entity keys' => [
      'id' => 'bcid',
      'label' => 'label',
      'revision' => 'revision_id',
    ],
    'admin ui' => [
      'path' => 'admin/config/media/brightcove/client',
      'controller class' => 'BrightcoveClientEntityUIController',
      'file' => 'brightcove.client.inc',
    ],
    'module' => 'brightcove',
    'access callback' => 'brightcove_client_access',
    'permission labels' => [
      'singular' => t('client'),
      'plural' => t('clients')
    ],
  ];

  $entity_info['brightcove_playlist'] = [
    'label' => t('Brightcove playlist'),
    // We don't store playlists locally.
    'base table' => NULL,
    'uri callback' => 'brightcove_playlist_uri',
    'controller class' => 'BrightcovePlaylistEntityController',
    'entity class' => 'Entity',
    'entity keys' => [
      'id' => 'bpid',
      'label' => 'label',
      'bundle' => 'type',
    ],
    'bundle keys' => array(
      'bundle' => 'type',
    ),
    'admin ui' => [
      'path' => 'admin/config/media/brightcove/playlist',
      'controller class' => 'BrightcovePlaylistEntityUIController',
      'file' => 'brightcove.playlist.inc',
      'menu wildcard' => '%brightcove_playlist',
    ],
    'module' => 'brightcove',
    'access callback' => 'brightcove_playlist_access',
    'permission labels' => [
      'singular' => t('playlist'),
      'plural' => t('playlists')
    ],
    'load hook' => 'brightcove_playlist_load',
    'bundles' => [
      BRIGHTCOVE_PLAYLIST_TYPE_MANUAL => [
        'label' => t('Manual playlist'),
      ],
      BRIGHTCOVE_PLAYLIST_TYPE_SMART => [
        'label' => t('Smart playlist'),
      ],
    ],
  ];

  return $entity_info;
}

/**
 * Implements hook_field_storage_info().
 */
function brightcove_field_storage_info() {
  return array(
    'brightcove_playlist_video_storage' => array(
      'label' => t('Storage of playlist videos'),
      'description' => t('Loads and saves the list of videos on a playlist.'),
    ),
  );
}

/**
 * Implements hook_field_storage_load().
 */
function brightcove_field_storage_load($entity_type, $entities, $age, $fields, $options) {
  if ($entity_type == 'brightcove_playlist') {
    foreach ($fields as $field_id => $ids) {
      $field = field_info_field_by_id($field_id);
      $field_name = $field ['field_name'];
      foreach ($ids as $id) {
        $video_ids = $entities[$id]->playlist->getVideoIds();
        foreach ($video_ids as $video_id) {
          $entities[$id]->{$field_name}[LANGUAGE_NONE][] = [
            'brightcove_id' => $video_id,
            'client_id' => $entities[$id]->client->bcid,
          ];
        }
      }
    }
  }
}

/**
 * Implements hook_field_storage_write().
 */
function brightcove_field_storage_write($entity_type, $entity, $op, $fields) {
  if ($entity_type == 'brightcove_playlist') {
    foreach ($fields as $field_id) {
      $field = field_info_field_by_id($field_id);
      $field_name = $field ['field_name'];
      if ($field['type'] == 'brightcove_field') {
        $videos = field_get_items($entity_type, $entity, $field_name);
        $video_ids = [];
        foreach ($videos as $video_id) {
          $video_ids[] = $video_id['brightcove_id'];
        }
        $entity->playlist->setVideoIds($video_ids);
      }
    }
  }
}

/**
 * Implements hook_libraries_info().
 */
function brightcove_libraries_info() {
  return [
    'PHP-API-Wrapper' => [
      'name' => 'Brightcove API Wrapper',
      'vendor url' => 'https://github.com/brightcove/PHP-API-Wrapper',
      'download url' => 'https://github.com/brightcove/PHP-API-Wrapper/archive/master.zip',
      'version callback' => '_brightcove_api_version',
      'files' => [
        'php' => [
          'brightcove.php',
          'brightcove_cms.php',
          'brightcove_di.php',
        ],
      ],
    ],
  ];
}

/**
 * Load brightcove php wrapper library.
 */
function brightcove_load_lib() {
  libraries_load('PHP-API-Wrapper');
}

/**
 * Version callback for brightcove_libraries_info().
 *
 * @return string
 */
function _brightcove_api_version() {
  return '0.1';
}

/**
 * URI callback for brightcove_client entity.
 */
function brightcove_account_uri($entity) {
  return [
    'path' => 'admin/config/media/brightcove/brightcove_client/' . entity_id('brightcove_client', $entity),
  ];
}

/**
 * Access callback for brightcove_client entity.
 *
 * @param $op
 *   Can be 'edit' or 'use'.
 * @param $entity
 *   Brightcove client entity or client ID.
 * @param $account
 *   Loaded user account.
 * @return bool
 */
function brightcove_client_access($op, $entity = NULL, $account = NULL) {
  // If we got ID try to load the entity.
  if (is_numeric($entity)) {
    $entity = brightcove_client_load($entity);
  }

  // If account is not set use the currently logged in user.
  if (is_null($account)) {
    global $user;
    $account = $user;
  }

  switch ($op) {
    case 'use':
      return user_access('use brightcove client ' . $entity->bcid, $account) || user_access('administer brightcove settings', $account);
    default:
      return user_access('administer brightcove settings', $account);
  }
}

/**
 * Saves a brightcove_client.
 */
function brightcove_client_save($client) {
  entity_get_controller('brightcove_client')->save($client);
}

/**
 * Load a brightcove client entity.
 *
 * @param string $client_id
 *  The client id
 * @return Entity
 *  The clietn entity object.
 */
function brightcove_client_load($client_id) {
  return entity_load_single('brightcove_client', $client_id);
}

function brightcove_client_load_or_default($client_id = NULL) {
  if ($client_id) {
    $client = brightcove_client_load($client_id);
    if ($client) {
      return $client;
    }
  }

  if (($default_client_id = variable_get('brightcove_client_default'))) {
    $client = brightcove_client_load($default_client_id);
    if ($client) {
      return $client;
    }
  }

  return FALSE;
}

/**
 * Implements hook_permission().
 */
function brightcove_permission() {
  $permissions = [
    'administer brightcove settings' => [
      'title' => t('Administer brightcove'),
    ],
    'browse videos' => [
      'title' => t('Browse videos'),
    ],
    'upload videos' => [
      'title' => t('Upload videos'),
    ],
    'browse playlists' => [
      'title' => t('Browse playlists'),
    ],
    'administer brightcove playlists' => [
      'title' => t('Administer playlists'),
    ],
  ];

  // There's a separate permission for each brightcove client to use them.
  $clients = db_select('brightcove_client', 'bc')
    ->fields('bc', ['bcid', 'label'])
    ->execute()
    ->fetchAllKeyed();
  foreach ($clients as $bcid => $label) {
    $permissions['use brightcove client ' . $bcid] = [
      'title' => t('Use the @label client', ['@label' => $label]),
    ];
  }

  return $permissions;
}

/**
 * Implementation of hook_ctools_plugin_api().
 *
 * Tell CTools that we support the default_mymodule_presets API.
 */
function brightcove_ctools_plugin_api($owner, $api) {
  if ($owner == 'brightcove' && $api == 'brightcove') {
    return ['version' => 1];
  }
}

/**
 * Implementation of hook_ctools_plugin_directory().
 */
function brightcove_ctools_plugin_directory($module, $type) {
  // Load the export_ui plugin.
  if ($type =='export_ui') {
    return 'plugins/export_ui';
  }
}

/**
 * Autocomplete callback for listing videos.
 *
 * @param Entity $client
 *  The client entity object to use for aurocompleting videos.
 * @param string $videos_typed
 *  The string of comma-separated videos typed so far.
 */
function brightcove_autocomplete_videos($client, $videos_typed) {
  $matches = [];
  $result = [];

  list($cms,) = _brightcove_create_classes($client);
  $videos_typed = drupal_explode_tags($videos_typed);
  $video_last = drupal_strtolower(array_pop($videos_typed));
  try {
    $result = $cms->listVideos($video_last);
  }
  catch (Exception $error) {
    watchdog('brightcove', 'Finding videos in autocomplete failed.', [], WATCHDOG_ERROR);
  }

  foreach ($result as $video) {
    // Note: Video ID is autogenerated by Brightcove and thus doesn't require XSS protection.
    $matches[check_plain($video->getName()) . ' [id:' . $video->getId() . ']'] = check_plain($video->getName()) . ' [id:' . $video->getId() . ']';
  }

  $prefix = count($videos_typed) ? drupal_implode_tags($videos_typed) . ', ' : '';
  $video_matches = [];
  foreach ($matches as $name) {
    $video_matches[$prefix . $name] = check_plain($name);
  }
  drupal_json_output($video_matches);
}

/**
 * Return the path to the Brightcove MAPI library.
 *
 * If brightcove_variable_get('brightcove_mapi_path') has not yet been set, then
 * this will attempt to autodiscover the path if the bc-mapi.php file exists
 * within sites/all/libraries/* or sites/example.com/libraries/*. It will also
 * set the path to media_brightcove_variable_get('brightcove_mapi_path').
 *
 * The library is available from http://opensource.brightcove.com/project/PHP-MAPI-Wrapper/.
 *
 * @return string
 *   The path to the bc-mapi.php file.
 */
function brightcove_mapi_path() {
  $path = &drupal_static(__FUNCTION__);

  if (!isset($path)) {
    if (!($path = variable_get('brightcove_mapi_path', FALSE))) {
      $files = drupal_system_listing('/^bc-mapi\.php$/', 'libraries',
                                     'filename', 0);
      if (isset($files['bc-mapi.php'])) {
        $path = dirname($files['bc-mapi.php']->uri);
        variable_set('brightcove_mapi_path', $path);
      }
    }
  }

  return $path;
}

/**
 * Implements hook_file_mimetype_mapping_alter().
 *
 * Regsiter the video/brightcove mimetype.
 */
function brightcove_file_mimetype_mapping_alter(&$mapping) {
  $mapping['mimetypes'][] = 'video/brightcove';
}

/**
 * Check a set of API keys to determine write access to Brightcove Studio.
 * Only customers with Professional and higher accounts have write access.
 *
 * @return bool
 *  TRUE for write access allowed.
 *  FALSE for write access forbidden.
 */
function brightcove_write_api_access() {
  return (bool) variable_get('brightcove_write_api_key', FALSE);
}

/**
 * Loads Brightcove video from CMS API.
 *
 * Uses a 5 minutes cache to speed up lookups.
 *
 * @param string $video_id
 * @param stdClass $client_entity
 * @param bool $reset
 * @return BrightcoveVideo|bool Video object or FALSE if video not found.
 * Video object or FALSE if video not found.
 */
function brightcove_video_load($video_id, $client_entity, $reset = FALSE) {
  if (!$client_entity) {
    return FALSE;
  }

  brightcove_load_lib();
  $cid = "brightcove:video:{$video_id}:{$client_entity->bcid}";
  $cache = brightcove_cache_get($cid);
  if (!empty($cache) && !$reset) {
    return $cache;
  }
  else {
    list($cms,) = _brightcove_create_classes($client_entity);
    try {
      $video = $cms->getVideo($video_id);
      if ($video) {
        brightcove_cache_set($cid, $video);
        return $video;
      }
    }
    catch (Exception $e) {}
  }
  return FALSE;
}

/**
 * Function that saves a remote image as a local file.
 *
 * @param string $url
 *   Remote image URL.
 *
 * @return string|bool
 *   Returns FALSE if image doesn't exist, cannot be saved or is not image (based on extension).
 *   Returns $file object if image already exists or was saved correctly.
 */
function brightcove_remote_image($url) {
  $parse = parse_url($url);
  $path = pathinfo($parse['path']);
  $fullpath = drupal_realpath(file_default_scheme() . '://brightcove_thumbnail');
  $final_file = $fullpath . '/' . $path['basename'];

  if (file_exists($final_file)) {
    return file_build_uri('brightcove_thumbnail/' . $path['basename']);
  }

  // Perform basic extension check.
  if (!in_array(drupal_strtolower($path['extension']), ['jpg', 'jpeg', 'png', 'gif'])) {
    return FALSE;
  }

  if (!file_prepare_directory($fullpath, FILE_CREATE_DIRECTORY|FILE_MODIFY_PERMISSIONS)) {
    return FALSE;
  }

  $ch = curl_init();
  curl_setopt($ch, CURLOPT_URL, $url);
  curl_setopt($ch, CURLOPT_HEADER, FALSE);
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
  // Causes a warning if PHP safe mode is on.
  @curl_setopt($ch, CURLOPT_FOLLOWLOCATION, TRUE);
  $rawdata = curl_exec($ch);
  if (($fp = @fopen($final_file, 'x'))) {
    fwrite($fp, $rawdata);
    fclose($fp);
  }

  return file_build_uri('brightcove_thumbnail/' . $path['basename']);
}

/**
 * Implements of hook_theme().
 */
function brightcove_theme() {
  return [
    'brightcove_unavailable_message' => [
      'variables' => ['message' => NULL],
    ],
  ];
}

function theme_brightcove_unavailable_message($variables) {
  return '<div class="video-unavailable">' . $variables['message'] . '</div>';
}

/**
 * Returns a default image for videos without a thumbnail or still image.
 *
 * @return string
 *   Path for the Brightcove placeholder image.
 */
function brightcove_get_default_image() {
  return drupal_get_path('module', 'brightcove') . '/images/default-image.png';
}

/**
 * Check if expose unavailability message in case the video is not available.
 *
 * @return
 *   Returns a themed message if checks are enabled.
 */
function brightcove_expose_unavailable() {
  if (variable_get('brightcove_check_for_unavailable', TRUE) &&
    ($unavailable_message = variable_get('brightcove_status_display_unavailable', 'This video is unavailable for the moment.'))) {
    return theme('brightcove_unavailable_message', ['message' => $unavailable_message]);
  }

  return '';
}

/**
 * @param $client_entity
 * @return BrightcoveClient
 * @throws BrightcoveAuthenticationException
 */
function _brightcove_create_client($client_entity) {
  brightcove_load_lib();
  $client_id = $client_entity->client_id;
  $client_secret = $client_entity->client_secret;

  return BrightcoveClient::authorize($client_id, $client_secret);
}

function _brightcove_create_classes($client_entity) {
  $client = _brightcove_create_client($client_entity);
  $account = $client_entity->account_id;
  $cms = new BrightcoveCMS($client, $account);
  $di = new BrightcoveDI($client, $account);

  return [$cms, $di];
}

/**
 * @param $client_entity
 * @param $url
 * @param $profile
 * @param $hash
 * @param null|callable $metadata_callback
 * @return BrightcoveVideo
 */
function brightcove_upload_and_ingest($client_entity, $url, $profile, $hash, callable $metadata_callback = NULL) {
  brightcove_load_lib();
  list($cms, $di) = _brightcove_create_classes($client_entity);

  $video = new BrightcoveVideo();
  if ($metadata_callback !== NULL) {
    $metadata_callback($video, $cms);
  }

  $video = $cms->createVideo($video);
  $request = BrightcoveIngestRequest::createRequest($url, $profile);
  if (($callback = _brightcove_get_ingest_callback($hash))) {
    $request->setCallbacks([$callback]);
  }
  $di->createIngest($video->getId(), $request);

  return $video;
}

function _brightcove_get_ingest_callback($hash) {
  if (!variable_get('brightcove_track_ingestion')) {
    return FALSE;
  }

  if (variable_get('brightcove_auto_callback', TRUE)) {
    return url("brightcove/callback/{$hash}", ['absolute' => TRUE]);
  }

  return rtrim(variable_get('brightcove_callback'), '/') . "/{$hash}";
}

function brightcove_handle_ingest_callback($hash) {
  $row = db_query("SELECT * FROM {brightcove_callback} WHERE id = :hash", [':hash' => $hash])->fetchAssoc();
  if (!$row) {
    drupal_not_found();
    return;
  }

  $fid = $row['fid'];
  file_delete(file_load($fid));
  db_delete('brightcove_callback')
    ->condition('id', $hash)
    ->execute();

  return NULL;
}

/**
 * Parse a field value in form of "title [id:123]" and return 123
 *
 * @param $id
 *   Video ID in form of "title [id:123]".
 * @return
 *   Int value of the ID or NULL if not found.
 */
function brightcove_parse_id($id) {
  preg_match('/\[id:([^\[]*)\]$/', $id, $matches);
  if (count($matches) == 2) {
    return $matches[1];
  }
  return NULL;
}

/**
 * Generate a reference ID based on Drupal version and User ID.
 *
 * @param $account
 *   Account UID that is responsible for this video. If NULL, logged in user is used.
 */
function brightcove_generate_reference($account = NULL) {
  global $user;
  if (!isset($account)) {
    $account = $user->uid;
  }
  return "drupal:" . DRUPAL_CORE_COMPATIBILITY . ":" . $account . ":" . md5(microtime());
}

/**
 * Load a player.
 *
 * @param $name
 * @return mixed
 */
function brightcove_player_load($name) {
  // Try to get the default player.
  if (empty($name)) {
    $default_player = variable_get('brightcove_player_default', NULL);

    // If no default player is set, show an error message.
    if (is_null($default_player)) {
      drupal_set_message(t('Default player is not set, please set one on the !link page.', ['!link' => l(t('Brightcove settings'), 'admin/config/media/brightcove/players')]), 'error');
    }

    return $default_player;
  }

  // Return the player with the given name.
  $players = brightcove_player_load_all();

  // If the currently selected player is not available (eg. it was deleted) use
  // the default player.
  if (!isset($players[$name])) {
    $name = variable_get('brightcove_player_default');
  }
  return $players[$name];
}

/**
 * Load all players.
 *
 * @return mixed
 */
function brightcove_player_load_all() {
  ctools_include('export');
  return ctools_export_crud_load_all('brightcove_player');
}

/**
 * Get players list.
 *
 * @param array $instance
 *   Entity specific instance.
 *
 * @return mixed
 */
function brightcove_player_list($instance = NULL) {
  $players = brightcove_player_load_all();

  // Get the entity specific default player.
  if (!is_null($instance) && isset($players[$instance['settings']['brightcove_player']])) {
    $default_player = $players[$instance['settings']['brightcove_player']]->display_name;
  }
  // Otherwise if not set get the globally set default player.
  else {
    $default_player = variable_get('brightcove_player_default', t('none'));
    if (isset($players[$default_player])) {
      $default_player = $players[$default_player]->display_name;
    }
  }

  $return = ['' => t('Default (@default_player)', ['@default_player' => $default_player])];
  foreach ($players as $id => $player) {
    $return[$id] = $player->display_name;
  }
  return $return;
}

/**
 * Get the default player.
 *
 * @return mixed|null
 */
function brightcove_default_player() {
  $default = variable_get('brightcove_player_default', NULL);

  if (is_null($default)) {
    drupal_set_message(t("The default brightcove player has not been defined yet."), 'warning');
    return NULL;
  }

  return brightcove_player_load($default);
}

/**
 * Save a player.
 *
 * @param $player
 * @return DatabaseStatementInterface|int|null
 */
function brightcove_player_save($player) {
  ctools_include('export');
  return ctools_export_crud_save('brightcove_player', $player);
}

/**
 * Delete a player.
 *
 * @param $player
 * @return DatabaseStatementInterface
 */
function brightcove_player_delete($player) {
  ctools_include('export');
  return ctools_export_crud_delete('brightcove_player', $player);
}

/**
 * Loads all clients which belong to a given or current user.
 *
 * @param null|stdClass $account
 * @return array
 */
function _brightcove_load_my_clients($account = NULL) {
  // Load all brightcove_client entities.
  // We need $reset = TRUE otherwise we get no clients in an AJAX call.
  $clients = entity_load('brightcove_client', FALSE, [], TRUE);

  // Keep only the clients $account has access to.
  $clients = array_filter($clients, function ($client) use ($account) {
    return brightcove_client_access('use', $client, $account);
  });

  return $clients;
}

function _brightcove_my_client_select_options($account = NULL) {
  $clients = _brightcove_load_my_clients($account);
  $clients_options = [];
  foreach ($clients as $client) {
    $clients_options[$client->bcid] = $client->label;
  }

  return $clients_options;
}

/**
 * Base brightcove upload form.
 *
 * This is not a complete form, and should not be called directly.
 *
 * @see brightcove_field_upload_form()
 * @see brightcove_media_upload_form()
 */
function _brightcove_upload_form($form, &$form_state) {
  $form = [];

  drupal_prepare_form('brightcove_upload_form', $form, $form_state);

  $client = $form_state['build_info']['args'][0];

  // Check for existing clients.
  $clients = _brightcove_load_my_clients();
  if (empty($clients)) {
    drupal_set_message(t('No clients configured'), 'error');
    return $form;
  }
  else {
    $form['client'] = [
      '#type' => 'hidden',
      '#value' => $client->bcid,
    ];
  }

  $form['file_upload'] = [
    '#type' => 'file',
    '#title' => t('Video') . ' <span class="form-required" title="' . t('This field is required.') . '">*</span>',
    '#size' => 40,
  ];

  $form['title'] = [
    '#type' => 'textfield',
    '#title' => t('Name'),
    '#required' => TRUE,
    '#default_value' => !empty($form_state['values']['title']) ? $form_state['values']['title'] : '',
  ];

  $form['short'] = [
    '#type' => 'textarea',
    '#rows' => 2,
    '#title' => t('Short description'),
    '#default_value' => !empty($form_state['values']['short']) ? $form_state['values']['short'] : '',
  ];

  $form['long'] = [
    '#type' => 'textarea',
    '#rows' => 2,
    '#title' => t('Long description'),
    '#default_value' => !empty($form_state['values']['long']) ? $form_state['values']['long'] : '',
  ];

  $form['reference_id'] = [
    '#type' => 'textfield',
    '#title' => t('Reference ID'),
    '#default_value' => !empty($form_state['values']['reference_id']) ? $form_state['values']['reference_id'] : '',
    '#description' => t('Leave empty to generate ID automatically.'),
  ];

  $form['tags'] = [
    '#type' => 'textfield',
    '#title' => t('Tags'),
    '#description' => t('Separate tags with a comma; no tag > 128 characters'),
    '#default_value' => !empty($form_state['values']['tags']) ? $form_state['values']['tags'] : '',
  ];

  $form['state'] = [
    '#type' => 'select',
    '#title' => t('State'),
    '#options' => [
      'ACTIVE' => t('Active'),
      'INACTIVE' => t('Inactive'),
    ],
    '#default_value' => !empty($form_state['values']['state']) ? $form_state['values']['state'] : TRUE,
  ];

  $form['custom_fields'] = [
    '#type' => 'fieldset',
    '#title' => t('Custom fields'),
    '#collapsible' => TRUE,
  ];

  try {
    list($cms,) = _brightcove_create_classes($client);
    $fields = $cms->getVideoFields();
    $has_required = FALSE;
    $types = [
      'string' => 'textfield',
      'enum' => 'select',
    ];
    foreach ($fields->getCustomFields() as $field) {
      $has_required = $has_required || $field->isRequired();
      $form['custom_fields']["custom_field_{$field->getId()}"] = [
        '#title' => $field->getDisplayName(),
        '#description' => $field->getDescription(),
        '#required' => $field->isRequired(),
        '#type' => $types[$field->getType()],
      ];
      if ($field->getType() === 'enum') {
        $form['custom_fields']["custom_field_{$field->getId()}"]['#options'] = drupal_map_assoc($field->getEnumValues());
      }
    }
    $form['custom_fields']['#collapsed'] = !$has_required;
  } catch (BrightcoveAPIException $ex) {
    $form['custom_fields']['#access'] = FALSE;
  }

  $form['schedule'] = [
    '#type' => 'fieldset',
    '#title' => t('Availability'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#attached' => [
      'js' => [
        drupal_get_path('module', 'brightcove_field') . '/js/schedule.js',
      ],
      'css' => [
        drupal_get_path('module', 'brightcove_field') . '/styles/schedule.css',
      ]
    ],
  ];

  $form['schedule']['start_availability_date'] = [
    '#type' => 'date_popup',
    '#date_format' => 'Y-m-d H:i',
    '#date_timezone' => date_default_timezone(),
    '#date_label_position' => 'hidden',
    '#default_value' => !empty($form_state['values']['start_availability_date']) ? $form_state['values']['start_availability_date'] : format_date(REQUEST_TIME, 'custom', 'Y-m-d') . ' 00:00:00',
    '#prefix' => '<div id="brightcove-start-availability-date">',
    '#suffix' => '</div>',
    '#pre_render' => ['_brightcove_schedule_start_end_date_pre_render'],
  ];
  $form['schedule']['start_date'] = [
    '#type' => 'radios',
    '#title' => t('Starting'),
    '#default_value' => 'immediately',
    '#options' => [
      'immediately' => t('Immediately'),
      'date_set' => ' ',
    ],
  ];

  $form['schedule']['end_availability_date'] = [
    '#type' => 'date_popup',
    '#date_format' => 'Y-m-d H:i',
    '#date_timezone' => date_default_timezone(),
    '#date_label_position' => 'hidden',
    '#default_value' => !empty($form_state['values']['end_availability_date']) ? $form_state['values']['end_availability_date'] : format_date(REQUEST_TIME, 'custom', 'Y-m-d') . ' 23:59:59',
    '#prefix' => '<div id="brightcove-end-availability-date">',
    '#suffix' => '</div>',
    '#pre_render' => ['_brightcove_schedule_start_end_date_pre_render'],
  ];
  $form['schedule']['end_date'] = [
    '#type' => 'radios',
    '#title' => t('Ending'),
    '#default_value' => 'no_end_date',
    '#options' => [
      'no_end_date' => t('No end date'),
      'date_set' => ' ',
    ],
  ];

  $form['advanced'] = [
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Advanced'),
  ];

  $form['advanced']['linktext'] = [
    '#type' => 'textfield',
    '#title' => t('Related link text'),
    '#default_value' => !empty($form_state['values']['linktext']) ? $form_state['values']['linktext'] : '',
  ];

  $form['advanced']['linkurl'] = [
    '#type' => 'textfield',
    '#title' => t('Related link url'),
    '#default_value' => !empty($form_state['values']['linkurl']) ? $form_state['values']['linkurl'] : '',
  ];

  $form['advanced']['economics'] = [
    '#type' => 'select',
    '#title' => t('Economic model'),
    '#options' => [
      BRIGHTCOVE_ECONOMICS_FREE => t('No advertising'),
      BRIGHTCOVE_ECONOMICS_AD_SUPPORTED => t('Advertising'),
    ],
    '#description' => t('If set to "Advertising", ads may be shown when viewers watch this video'),
    '#default_value' => !empty($form_state['values']['economics']) ? $form_state['values']['economics'] : BRIGHTCOVE_ECONOMICS_FREE
  ];

  $form['advanced']['profile'] = [
    '#type' => 'select',
    '#title' => t('Video encoding profile'),
    '#options' => drupal_map_assoc(brightcove_standard_profile_list()),
  ];

  $form['additional_fields'] = [
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Additional fields'),
  ];

  // Attach additional fields.
  $entity = entity_create('brightcove_video', array('type' => 'brightcove_video'));
  field_attach_form('brightcove_video', $entity, $form['additional_fields'], $form_state);

  $form['#validate'][] = '_brightcove_upload_form_validate';

  return $form;
}

/**
 * Validate callback for _brightcove_upload_form().
 */
function _brightcove_upload_form_validate($form, &$form_state) {
  if (!in_array($form_state['values']['client'], array_keys(_brightcove_load_my_clients()))) {
    form_error($form['client'], t('Invalid client selected.'));
  }
}

function _brightcove_schedule_start_end_date_pre_render($elements) {
  // Remove descriptions from the date and time fields.
  unset($elements['date']['#description']);
  unset($elements['time']['#description']);

  return $elements;
}

/**
 * Upload the submitted video.
 *
 * @param $form
 * @param $form_state
 * @return bool|StdClass
 */
function _brightcove_upload_form_callback(&$form, $form_state) {
  $limits['extensions'] = '3g2 3gp asf avi dv flv f4v m4v mov mp4 mpeg mpg mts m2ts qt wmv';
  $validators = [
    'file_validate_extensions' => [$limits['extensions']],
  ];

  $file = file_save_upload('file_upload', $validators, file_default_scheme() . '://');

  if (!$file) {
    drupal_set_message(t('Only Video files are allowed here.'), 'error');
    return $form;
  }

  if ($file->filesize <= 0) {
    // Some uploaded files had zero size, that's an error.
    drupal_set_message(t('Uploaded file not found. Are you sure that you uploaded an existing file?'), 'error');
    return $form;
  }

  if (form_get_errors()) {
    return $form;
  }

  $client = entity_load_single('brightcove_client', $form_state['values']['client']);
  try {
    $hash = hash('sha512', mt_rand());
    $video = brightcove_upload_and_ingest($client, file_create_url($file->uri), $form_state['values']['profile'], $hash, function ($video, $cms) use ($form_state) {
      // Generate a reference id if the user left it empty.
      $reference_id = (!empty($form_state['values']['reference_id']) ? $form_state['values']['reference_id'] : brightcove_generate_reference());

      $video
        ->setName($form_state['values']['title'])
        ->setDescription($form_state['values']['short'])
        ->setLongDescription($form_state['values']['long'])
        ->setLink((new BrightcoveVideoLink())
          ->setText($form_state['values']['linktext'])
          ->setUrl($form_state['values']['linkurl'])
        )
        ->setState($form_state['values']['state'] ? 'ACTIVE' : 'INACTIVE')
        ->setEconomics($form_state['values']['economics'])
        ->setReferenceId($reference_id)
      ;

      // Set start/end availability dates if one of them was given.
      if ($form_state['values']['start_date'] == 'date_set' || $form_state['values']['end_date'] == 'date_set') {
        $video_schedule = (new BrightcoveVideoSchedule());
        if ($form_state['values']['start_date'] == 'date_set') {
          $datetime = new DateTime($form_state['values']['start_availability_date']);
          $video_schedule->setStartsAt($datetime->format(DateTime::ISO8601));
        }

        if ($form_state['values']['end_date'] == 'date_set') {
          $datetime = new DateTime($form_state['values']['end_availability_date']);
          $video_schedule->setEndsAt($datetime->format(DateTime::ISO8601));
        }

        $video->setSchedule($video_schedule);
      }

      $fields = $cms->getVideoFields();
      $ids = array_map(function ($field) {
        return $field->getId();
      }, $fields->getCustomFields());
      $custom_fields = [];
      foreach ($ids as $id) {
        if (!empty($form_state['values']["custom_field_{$id}"])) {
          $custom_fields[$id] = $form_state['values']["custom_field_{$id}"];
        }
      }
      if ($custom_fields) {
        $video->setCustomFields($custom_fields);
      }

      if (!empty($form_state['values']['tags'])) {
        $tags = explode(',', $form_state['values']['tags']);
        $tags = array_map('trim', $tags);
        $video->setTags($tags);
      }
    });

    return $video->getId();
  } catch (Exception $e) {
    watchdog_exception('brightcove_upload', $e);
  }

  return FALSE;
}

/**
 * Return the cached data based on the type of the caching.
 *
 * @param $cid
 *   The id of the cache.
 *
 * @return mixed
 *   The cached data, if exists, FALSE otherwise.
 */
function brightcove_cache_get($cid) {
  // If cache is enabled.
  if ( variable_get('brightcove_cache_enabled', TRUE)) {
    // Get the type of cache being set.
    $type = variable_get('brightcove_cache_type', 'db');
    switch ($type) {
      case 'db':
        $cache = cache_get($cid, 'cache_brightcove');
        if ($cache) {
          return $cache->data;
        }
        break;
      case 'file':
      case 'memcached':
        $bc_cache = brightcove_cache_initialize();
        $cache = $bc_cache->get($cid);
        return json_decode($cache, TRUE);
        break;
    }
  }
  return FALSE;
}

/**
 * Cache Brightcove data according to the type of caching being set.
 *
 * @param $cid
 *   The id of the cache.
 * @param $data
 *   The data going to be cached
 * .
 * @return mixed
 *   The cached data, if exists, NULL otherwise.
 */
function brightcove_cache_set($cid, $data) {
  // If cache is enabled.
  if ( variable_get('brightcove_cache_enabled', TRUE)) {
    // Get the type of cache being set.
    $type = variable_get('brightcove_cache_type', 'db');
    switch ($type) {
      case 'db':
        // Get type related settings.
        $cache_settings = variable_get('brightcove_cache_db', []);
        $cache_time = isset($cache_settings['cache_time']) ? $cache_settings['cache_time'] : 600;
        // Save data to cache table.
        cache_set($cid, $data, 'cache_brightcove', time() + $cache_time);
        break;
      case 'file':
      case 'memcached':
        $bc_cache = brightcove_cache_initialize();
        $bc_cache->set($cid, $data);
        break;
    }
  }
}

/**
 * Implements hook_flush_caches().
 */
function brightcove_flush_caches() {
  // If a user updates the module from an older version which is not include the cache table,
  // the update method will be broken, because the system will try to flush the cache from the
  // unexisting table as well.
  $tables = db_table_exists('cache_brightcove') ? ['cache_brightcove'] : [];
  return $tables;
}

/**
 * Invalidate outdated cache records.
 *
 * @param $cid
 * @param bool $wildcard
 */
function brightcove_invalidate_cache($cid, $wildcard = FALSE) {
  // If cache is enabled.
  if (variable_get('brightcove_cache_enabled', TRUE)) {
    // Get the type of cache being set.
    $type = variable_get('brightcove_cache_type', 'db');
    switch ($type) {
      case 'db':
        cache_clear_all($cid, 'cache_brightcove', $wildcard);
        break;
      case 'file':
        if ($wildcard) {
          // Remove all the cache files, when new file is added or an existing one is deleted, because we can't use
          // wildcard like we can when we cache to database.
          _brightcove_delete_cache_files();
        }
        else {
          _brightcove_delete_cache_files($cid);
        }
        break;
      case 'memcached':
        if ($wildcard) {
          // Remove all the cache files, when new file is added or an existing one is deleted, because we can't use
          // wildcard like we can when we cache to database.
          _brightcove_delete_memcached();
        }
        else {
          _brightcove_delete_memcached($cid);
        }
        break;
    }
  }
}

/**
 * Helper function to be able to delete unnecessary cache files.
 *
 * @param null $cid
 */
function _brightcove_delete_cache_files($cid = NULL) {
  $cache_settings = variable_get('brightcove_cache_file', []);
  $path = isset($cache_settings['path']) ? _brightcove_cache_fix_file_path($cache_settings['path']) : BRIGHTCOVE_CACHE_FILE_PATH;

  if ($cid) {
    $ext = isset($cache_settings['ext']) ? $cache_settings['ext'] : BRIGHTCOVE_CACHE_FILE_EXT;
    // Delete affected cache file.
    $file = $path . md5($cid) . '.' . $ext;
    unlink($file);
  }
  else {
    // If no cache id given, the module deletes all the cache files from the cache folder.
    $files = glob($path . '*');
    foreach ($files as $file) {
      if (is_file($file)) {
        unlink($file);
      }
    }
  }
}

/**
 * Helper function to be able to delete outdated memcached items.
 *
 * @param $cid
 */
function _brightcove_delete_memcached($cid = NULL) {
  $cache_settings = variable_get('brightcove_cache_memcached', []);
  $location = isset($cache_settings['path']) ? $cache_settings['path'] : BRIGHTCOVE_CACHE_MEMCACHE_PATH;
  $port = isset($cache_settings['port']) ? $cache_settings['port'] : BRIGHTCOVE_CACHE_MEMCACHE_PORT;

  $memcached = new Memcached();
  $memcached->addServer($location, $port);

  if ($cid) {
    $memcached->delete($cid);
  }
  else {
    // Remove all cache item.
    $memcached->flush();
  }

}

/**
 * Initialize Brightcove API Cache.
 *
 * @param null $type
 * @param null $time
 * @param null $location
 * @param null $extension
 * @param null $port
 * @return BCMAPICache|bool
 */
function brightcove_cache_initialize($type = NULL, $time = NULL, $location = NULL, $extension = NULL, $port = NULL) {
  include_once brightcove_mapi_path() . '/bc-mapi-cache.php';
  // Cache type.
  if (!$type) {
    $type = variable_get('brightcove_cache_type', 'db');
    if (!in_array($type, ['file', 'memcached'])) {
      drupal_set_message(t('Cannot initialize Brightcove API Cache. Contact site administrators.'), 'error');
      watchdog('brightcove', 'The given @type cache type is not supported by Brightcove MAPI SDK.', ['@type' => $type], WATCHDOG_ERROR);
      return FALSE;
    }
    else {
      $cache_settings = variable_get('brightcove_cache_' . $type, []);
    }
  }
  // Cache lifetime in seconds.
  if (!$time) {
    $time = isset($cache_settings['cache_time']) ? $cache_settings['cache_time'] : BRIGHTCOVE_CACHE_LIFETIME;
  }
  // Location of the cache dir or the Memcache server.
  if (!$location) {
    $default_path = ($type === 'file') ? BRIGHTCOVE_CACHE_FILE_PATH : BRIGHTCOVE_CACHE_MEMCACHE_PATH;
    $location = isset($cache_settings['path']) ? $cache_settings['path'] : $default_path;
  }
  // Check that the path of the cache directory has the closing "/" character.
  if ($type === 'file') {
    $location = _brightcove_cache_fix_file_path($location);
  }
  // Extension of the cache files.
  if (!$extension) {
    $extension = '.';
    $extension .= isset($cache_settings['ext']) ? $cache_settings['ext'] : BRIGHTCOVE_CACHE_FILE_EXT;
  }
  // Memcache port.
  if (!$port) {
    $port = isset($cache_settings['port']) ? $cache_settings['port'] : BRIGHTCOVE_CACHE_MEMCACHE_PORT;
  }
   try {
    $bc_cache = new BCMAPICache($type, $time, $location, $extension, $port);
  } catch (Exception $e) {
    watchdog_exception('brightcove', $e);
    return FALSE;
  }

  return $bc_cache;
}

/**
 * Returns the appropriate external URL to the BrightcoveExperiences.js file.
 *
 * @return string
 *  The appropriate external js URL.
 *
 * @see http://support.brightcove.com/en/video-cloud/docs/publishing-video-cloud-player-https-page
 */
function brightcove_get_experiences_js_url() {
  global $is_https;

  // Set the filename we want to load.
  $filename = 'BrightcoveExperiences.js';
  if (variable_get('brightcove_player_full_api', FALSE)) {
    $filename = 'BrightcoveExperiences_all.js';
  }

  // Set the appropriate protocol.
  $path = 'http://admin.brightcove.com/js/' . $filename;
  if ($is_https) {
    $path = 'https://sadmin.brightcove.com/js/' . $filename;
  }

  return $path;
}

/**
 * Returns the appropriate URL to the Brightcove viewer.
 *
 * The calling function should append appropriate query strings to this URL to
 * control the video and player.
 *
 * @return string
 *  Brightcove viewer path.
 *
 * @todo Find out how to detect this URL in a nice way;
 */
function brightcove_get_viewer_url() {
  global $is_https;

  $path = 'http://c.brightcove.com/services/viewer/federated_f9';
  if ($is_https) {
    $path = 'https://secure.brightcove.com/services/viewer/federated_f9';
  }

  return $path;
}

/**
 * Helper function to be able to add the closing "/" character, if it doesn't exist.
 *
 * @param $location
 * @return string
 */
function _brightcove_cache_fix_file_path($location) {
  return (substr($location, -1) === '/') ? $location : $location . '/';
}

function brightcove_standard_profile_list() {
  static $list = [
    'Express Standard',
    'Live - HD',
    'Live - Premium HD',
    'Live - Standard',
    'audio-only',
    'balanced-high-definition',
    'balanced-nextgen-player',
    'balanced-standard-definition',
    'high-bandwidth-devices',
    'low-bandwidth-devices',
    'mp4-only',
    'screencast',
    'single-rendition',
  ];

  return $list;
}

/**
 * Implements hook_exit().
 */
function brightcove_exit($destination = NULL) {
  // Redirect to the given path.
  if (isset($_SESSION['player_delete_redirect'])) {
    $goto = $_SESSION['player_delete_redirect'];
    unset($_SESSION['player_delete_redirect']);
    drupal_goto($goto);
  }
}
